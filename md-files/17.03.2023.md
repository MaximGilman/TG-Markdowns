## Потокам тоже трудно просыпаться
<br>
Современные ЯП часто используют примитивы синхронизации, такие как мьютексы и переменные состояния, для координации действий нескольких потоков или процессов. 

Одной из проблем, которая может возникнуть при использовании этих примитивов, является проблема потерянного пробуждения, которая возникает, когда поток ожидает, но не может быть разбужен сигналом, даже если другие потоки подали сигнал на побудку.
У Мориса Херлихи в книге это называлось `lost wake-up problem`


Проблема потери пробуждения может возникнуть по разным причинам, race condition, ошибки в коде, ограничения аппаратного обеспечения или слишком широкий ум программиста. Когда эта проблема возникает, ожидающий поток может оставаться заблокированным неопределенное время, что приведет к тупику или невосприимчивости всей системы.

Проще всего показать пример потерянного пробуждения через 
```csharp
Monitor.Pulse() / Monitor.Wait()
```
Это методы стандартного АПИ .NET для многопоточности, но их аналоги есть в любом уважающем себя языке программирования( кроме Python, т.к. он крутится под GIL и все равно больше одного потока за раз не пустит).


В Java и других языках `Pulse` может меняться на `Notify`, но суть не меняется.

---

Возьму типовой пример из книги "The Art of Multiprocessor Programming" - при оптимизации многопоточного метода добавления элемента в очередь программист допускает ошибку. Для сигнализирования о состояниях работы используется два состояния `notFull`, и `notEmpty`.
Ожидается, что наполнив очередь, мы будем ждать, пока кто-то из читателей не заберет хотя бы один элемент, и буду пустой, будем ждать, пока кто-то не напишет.

```csharp
public void enq(T x) {
    lock(lockObject) {
        if (count == items.length)
            notFull.Wait();
        
        // Код по добавлению элемента

        if (count == 1)
            notEmpty.Pulse();
    }
} 
```

Вроде все логично если очередь полная - блокируем потоки, пока место не освободится, если добавили элемент в пустую очередь и счетчик стал равен 1 - будим обработчик, чтобы пошел разребать.


Но представим такую ситуацию - два потока читают, два пишут.
1) Оба читателя ожидают появления в очереди хотя бы одного элемента.
2) Один из писателей добавляет элемент и будит одного из читателей.
3) Однако перед тем как передать блокировку читателю, второй писатель успевает положить в очередь еще один элемент.

В этом случае разгребать всю работу придется одному потоку-читателю, а второй будет курить.

---

Чтобы избежать потерянного пробуждения в текущем коде `Pulse` нужно заменить на `PulseAll` - разница этих методов в том, что `Pulse` будит один **какой-то** поток (важно, что какой-то, а не рандомный), а `PulseAll` - точно будит все ожидающие потоки. Во втором случае планировщик потоков превращается в воспитателя, старающего усадить детей по местам, однако этот хаос нам на пользу. Пока планировщик разбирается, контроллируемые(!) race-condition'ы, происходящие в порядке планирования потоков позволяют избежать `lost wake-up'ов` и не приводят к ошибкам.


Помимо этого, описанный случай может привести и ко второй проблеме - т.н. спонтанному пробуждению - `spurious wake-up`, когда поток спадает с ожидания, но не может продолжить работу, т.к. объект синхронизации заблокирован и условие его ожидания не выполнено.
В документации ко многим сигнальным объектам может быть написано буквально следующее 
> объект спадает с ожидания, когда получает сигнальное событие. Или в неопределенный момент времени...

**Прикольно, правда?**


Чтобы справиться со случайными пробуждениями, рекомендуется использовать цикл while с переменной условия, а не оператор if при ожидании переменной условия. То есть даже если мы случайно спадем с ожидания, цикл вернет нас обратно.

Решением нашей горе-очереди может стать следующий код


```csharp
public void enq(T x) {
    lock(lockObject) {
        while (count == items.length)
            notFull.Wait();
        
        // Код по добавлению элемента

        if (count == 1)
            notEmpty.PulseAll();
    }
} 
```

---

В целом, проблема потерянного пробуждения и ложное пробуждение являются общими проблемами в системах параллельного выполнения, использующих примитивы синхронизации.  Такие ошибки случаются редко, но если вы пишете систему, которая должна работать всегда и везде - они могут помешать. Тем более что решить такие проблемы не сложно.

А для их решения правила 2
- всегда зовем `PulseAll` вместо `Pulse`
- Всегда висим в ожидании по инварианту (используем `while`, вместо `if`)
